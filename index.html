<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rez Max</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
            cursor: crosshair;
        }
        canvas {
            display: block;
        }
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px;
            background: rgba(0,0,0,0.5);
            border-radius: 8px;
            border: 1px solid #0ff;
            box-shadow: 0 0 15px #0ff;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        #score, #level, #overdrive {
            font-size: 1.2em;
            text-shadow: 0 0 5px #0ff;
        }
        #mute-button, #help-button {
            background: rgba(0, 255, 255, 0.5);
            border: 1px solid #0ff;
            color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            text-align: center;
            font-family: 'Courier New', Courier, monospace;
            font-size: 1em;
            margin-top: 5px;
        }
        #mute-button:hover, #help-button:hover {
            background: rgba(0, 255, 255, 0.8);
        }
        #reticle {
            position: absolute;
            width: 50px;
            height: 50px;
            border: 2px solid #fff;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none; /* Allows clicks to pass through to the canvas */
            z-index: 100;
        }
        #reticle.locking {
            border-color: #f0f;
            transform: translate(-50%, -50%) scale(1.2);
            box-shadow: 0 0 20px #f0f;
        }
        .modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            text-align: center;
            transition: opacity 0.5s ease;
        }
        .modal-content {
             background: rgba(0,20,20,0.9);
             padding: 30px;
             border-radius: 10px;
             border: 1px solid #0ff;
             box-shadow: 0 0 25px #0ff;
             max-width: 600px;
        }
        .modal h1 {
            font-size: 3em;
            color: #0ff;
            text-shadow: 0 0 15px #0ff;
            margin: 0 0 20px 0;
        }
        .modal p {
            font-size: 1.2em;
            line-height: 1.6;
            margin: 20px;
            text-align: left;
        }
        .modal-button {
            padding: 15px 30px;
            font-size: 1.5em;
            color: #000;
            background: #0ff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 0 20px #0ff;
            transition: all 0.2s ease;
        }
        .modal-button:hover {
            background: #fff;
            box-shadow: 0 0 30px #fff;
        }
        #help-menu {
            display: none; /* Hidden by default */
        }
         #message-box {
            position: absolute;
            bottom: 10%;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 255, 255, 0.8);
            color: #000;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 1.5em;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none;
            text-align: center;
            box-shadow: 0 0 20px #0ff;
        }
        #message-box.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="start-screen" class="modal">
        <div class="modal-content">
            <h1 id="game-title">REZ MAX</h1>
            <p id="instructions">Hold Left Mouse Button to lock on. Release to fire.<br>Press Spacebar at 100% Overdrive to clear the screen. Avoid enemies.</p>
            <button id="start-button" class="modal-button">Initialize System</button>
        </div>
    </div>

    <div id="help-menu" class="modal">
        <div class="modal-content">
            <h1>HOW TO PLAY</h1>
            <p>
                <strong>OBJECTIVE:</strong> Survive the data stream by destroying enemies and evolving your form.
                <br><br>
                <strong>CONTROLS:</strong>
                <br>&bull; <strong>Aim:</strong> Move the mouse.
                <br>&bull; <strong>Lock-On:</strong> Hold the Left Mouse Button and sweep the cursor over enemies.
                <br>&bull; <strong>Fire:</strong> Release the Left Mouse Button.
                <br>&bull; <strong>Overdrive:</strong> Press Spacebar when the meter is at 100%.
                <br><br>
                <strong>EVOLUTION:</strong> Your score increases your Evolution Level. Higher levels add new layers to the music. Getting hit by an enemy degrades your level.
            </p>
            <button id="close-help-button" class="modal-button">Resume</button>
        </div>
    </div>

    <div id="ui-container">
        <div id="score">Score: 0</div>
        <div id="level">Evolution: 1</div>
        <div id="overdrive">Overdrive: 0%</div>
        <button id="mute-button">Mute</button>
        <button id="help-button">?</button>
    </div>
    
    <div id="reticle"></div>
    <div id="message-box"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tone@15.1.22/build/Tone.js"></script>

    <script>
        // --- DOM Elements ---
        const scoreEl = document.getElementById('score');
        const levelEl = document.getElementById('level');
        const overdriveEl = document.getElementById('overdrive');
        const reticleEl = document.getElementById('reticle');
        const startScreen = document.getElementById('start-screen');
        const startButton = document.getElementById('start-button');
        const messageBox = document.getElementById('message-box');
        const muteButton = document.getElementById('mute-button');
        const helpButton = document.getElementById('help-button');
        const helpMenu = document.getElementById('help-menu');
        const closeHelpButton = document.getElementById('close-help-button');
        const gameTitleEl = document.getElementById('game-title');
        const instructionsEl = document.getElementById('instructions');

        // --- Core Components ---
        let scene, camera, renderer, clock;
        let player, playerAvatar;
        let raycaster, mouse;
        
        // --- Game State ---
        let score = 0;
        let evolutionLevel = 1;
        let overdrive = 0;
        let isLocking = false;
        let lockedTargets = [];
        const MAX_LOCKS = 8;
        let gameStarted = false;
        let isPaused = false;
        let isMuted = false;
        let animationFrameId;

        // --- Game Objects ---
        let enemies = [];
        let projectiles = [];
        let particles = [];
        let path;
        let pathProgress = 0;
        let overdriveShockwave;

        // --- Audio Engine (Tone.js) ---
    // IMPORTANT: Always call initAudio() after a user gesture (e.g., button click) to allow AudioContext to start.
        let lockOnSynth, kick, clap, hihat, bassSynth, melodySynth, padSynth, fireWhoosh;
        let musicLoop, bassLoop, melodyLoop, padLoop;
        let canLockSound = true;
        
        // --- Level Design ---
        let levelEvents;
        let nextEventIndex = 0;

        // --- Initialization ---
        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 1, 1000);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            clock = new THREE.Clock();
            player = new THREE.Group();
            scene.add(player);
            updatePlayerAvatar();
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            createPath();
            createEnvironment();
            setupLevelEvents();
            
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('mousedown', onMouseDown, false);
            window.addEventListener('mouseup', onMouseUp, false);
            window.addEventListener('keydown', onKeyDown, false);
            muteButton.addEventListener('click', toggleMute);
            helpButton.addEventListener('click', pauseGame);
            closeHelpButton.addEventListener('click', resumeGame);
        }

        function initAudio() {
            // Instruments
            lockOnSynth = new Tone.PluckSynth({ attackNoise: 0.5, dampening: 4000, resonance: 0.7 }).toDestination();
            kick = new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 10, oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 1.4, attackCurve: 'exponential' } }).toDestination();
            clap = new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.001, decay: 0.1, sustain: 0 } }).toDestination();
            hihat = new Tone.MetalSynth({ frequency: 200, envelope: { attack: 0.001, decay: 0.1, release: 0.01 }, harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5 }).toDestination();
            bassSynth = new Tone.MonoSynth({ oscillator: { type: "fmsawtooth", modulationType: "triangle", modulationIndex: 2, harmonicity: 0.501 }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.2, release: 0.4 } }).toDestination();
            melodySynth = new Tone.FMSynth({ harmonicity: 1.2, modulationIndex: 10, detune: 0, oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.2, release: 0.5 }, modulation: { type: "triangle" }, modulationEnvelope: { attack: 0.05, decay: 0.1, sustain: 0.8, release: 0.5 } }).toDestination();
            const filter = new Tone.AutoFilter("4n").toDestination().start();
            padSynth = new Tone.PolySynth(Tone.AMSynth, { harmonicity: 1.5, detune: 0, oscillator: { type: "fatsawtooth" }, envelope: { attack: 0.1, decay: 0.2, sustain: 0.5, release: 1.2 }, modulation: { type: "sine" }, modulationEnvelope: { attack: 0.5, decay: 0, sustain: 1, release: 0.5 } }).connect(filter);
            fireWhoosh = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.005, decay: 0.2, sustain: 0 } }).toDestination();

            // Music Loops
            let beat = 0;
            musicLoop = new Tone.Loop(time => {
                if (beat % 4 === 0) kick.triggerAttackRelease('C1', '8n', time);
                if (beat % 2 === 0) hihat.triggerAttackRelease('16n', time + 0.001, 0.5);
                beat = (beat + 1) % 16;
            }, '8n');

            const bassPattern = ['C1', null, 'G0', null, 'C1', null, 'A0', null];
            bassLoop = new Tone.Sequence((time, note) => { if(note) bassSynth.triggerAttackRelease(note, '8n', time); }, bassPattern, '4n');

            const melodyPattern = ['C4', 'E4', 'G4', 'B4', 'C5', 'B4', 'G4', 'E4', 'D4', 'F4', 'A4', 'C5', 'B4', 'A4', 'F4', 'D4'];
            melodyLoop = new Tone.Sequence((time, note) => { melodySynth.triggerAttackRelease(note, "8n", time); }, melodyPattern, '8n');
            
            padLoop = new Tone.Loop(time => {
                padSynth.triggerAttackRelease('C2', '1m', time);
                padSynth.triggerAttackRelease('G2', '1m', time + 0.001);
                padSynth.triggerAttackRelease('C3', '1m', time + 0.002);
            }, '1m');

            Tone.Transport.bpm.value = 130;
            
            if (Tone.Transport.state !== 'started') {
                Tone.Transport.start();
            }
            
            if (musicLoop.state !== 'started') musicLoop.start(0);
            if (padLoop.state !== 'started') padLoop.start(0.001);
        }
        
        // --- Level and Enemy Creation ---

        function setupLevelEvents() {
            levelEvents = [
                { progress: 0.05, type: 'formation', formation: 'line', count: 4 }, { progress: 0.15, type: 'formation', formation: 'v_shape', count: 5 },
                { progress: 0.25, type: 'formation', formation: 'line', count: 6, movement: 'wave' }, { progress: 0.35, type: 'formation', formation: 'ring', count: 8, movement: 'rotate' },
                { progress: 0.50, type: 'formation', formation: 'v_shape', count: 3 }, { progress: 0.52, type: 'formation', formation: 'v_shape', count: 3 },
                { progress: 0.65, type: 'formation', formation: 'line', count: 8, movement: 'wave' }, { progress: 0.80, type: 'formation', formation: 'ring', count: 6, movement: 'rotate' },
            ];
            nextEventIndex = 0;
        }

        function checkLevelEvents() {
            if (nextEventIndex >= levelEvents.length) return;
            const event = levelEvents[nextEventIndex];
            if (pathProgress >= event.progress) {
                spawnFormation(event);
                nextEventIndex++;
            }
        }
        
        function spawnFormation(event) {
            const formationGroup = new THREE.Group();
            const spawnAhead = 0.15;
            const spawnPoint = path.getPointAt((pathProgress + spawnAhead) % 1);
            formationGroup.position.copy(spawnPoint);
            scene.add(formationGroup);

            for (let i = 0; i < event.count; i++) {
                const enemy = createEnemy();
                switch(event.formation) {
                    case 'line': enemy.position.x = (i - (event.count - 1) / 2) * 10; break;
                    case 'v_shape': enemy.position.x = (i - Math.floor(event.count / 2)) * 10; enemy.position.z = -Math.abs(i - Math.floor(event.count / 2)) * 10; break;
                    case 'ring': const angle = (i / event.count) * Math.PI * 2; enemy.position.x = Math.cos(angle) * 20; enemy.position.y = Math.sin(angle) * 20; break;
                }
                enemy.userData.formationGroup = formationGroup;
                enemy.userData.movement = event.movement;
                enemy.userData.initialPos = enemy.position.clone();
                formationGroup.add(enemy);
                enemies.push(enemy);
            }
        }

        function createEnemy() {
            const enemyTypes = [ { geo: new THREE.IcosahedronGeometry(3, 0), color: 0xff00ff }, { geo: new THREE.TorusGeometry(3, 1, 4, 8), color: 0xffff00 }, { geo: new THREE.ConeGeometry(3, 8, 4), color: 0x00ff00 }];
            const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
            const material = new THREE.MeshBasicMaterial({ color: type.color, wireframe: true });
            const enemy = new THREE.Mesh(type.geo, material);
            enemy.userData.isEnemy = true;
            enemy.userData.isLocked = false;
            const outlineGeo = new THREE.EdgesGeometry(enemy.geometry);
            const outlineMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0 });
            const outline = new THREE.LineSegments(outlineGeo, outlineMat);
            enemy.add(outline);
            enemy.userData.outline = outline;
            return enemy;
        }

        function createPath() {
            path = new THREE.CatmullRomCurve3([ new THREE.Vector3(0, 5, 200), new THREE.Vector3(0, 5, 0), new THREE.Vector3(50, 10, -50), new THREE.Vector3(0, 15, -150), new THREE.Vector3(-80, 20, -250), new THREE.Vector3(-60, 10, -400), new THREE.Vector3(60, 15, -550), new THREE.Vector3(0, 5, -700) ]);
            const points = path.getPoints(500);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: 0x00ffff, opacity: 0.2, transparent: true });
            const curveObject = new THREE.Line(geometry, material);
            scene.add(curveObject);
        }

        function createEnvironment() {
            const gridHelper = new THREE.GridHelper(2000, 100, 0x00ffff, 0x00ffff);
            gridHelper.material.opacity = 0.2;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);
            const boxGeo = new THREE.BoxGeometry(10, 10, 10);
            for (let i = 0; i < 200; i++) {
                const material = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });
                const box = new THREE.Mesh(boxGeo, material);
                box.position.set((Math.random() - 0.5) * 1500, (Math.random() - 0.5) * 500, (Math.random() - 0.5) * 2000);
                scene.add(box);
            }
        }
        
        function createProjectile(start, end) {
            // Rez-style: improved arc projectile
            const mid = start.clone().lerp(end, 0.5);
            const dir = end.clone().sub(start).normalize();
            const perp = new THREE.Vector3(-dir.z, 0, dir.x).normalize(); // Perpendicular in XZ plane
            const control = mid.clone().add(perp.multiplyScalar(10)); // 10 units offset for arc
            const curve = new THREE.QuadraticBezierCurve3(start, control, end);
            const points = curve.getPoints(32);
            const geo = new THREE.BufferGeometry().setFromPoints(points);
            const mat = new THREE.LineBasicMaterial({ color: 0x00ffff, linewidth: 4, transparent: true, opacity: 0.9 });
            const projectile = new THREE.Line(geo, mat);
            projectile.userData.curve = curve;
            projectile.userData.t = 0;
            projectile.userData.speed = 1.5; // seconds to reach target
            projectile.userData.target = end.clone();
            projectile.userData.start = start.clone();
            projectile.userData.control = control.clone();
            projectiles.push(projectile);
            scene.add(projectile);
        }
        
        function createExplosion(position, color) {
            const particleCount = 40;
            for (let i = 0; i < particleCount; i++) {
                const geo = new THREE.SphereGeometry(0.25, 6, 6);
                const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.9 });
                const particle = new THREE.Mesh(geo, mat);
                particle.position.copy(position);
                // Color cycling for Rez effect
                const hue = (i / particleCount) * 360;
                particle.material.color.setHSL(hue/360, 1, 0.5);
                particle.userData.velocity = new THREE.Vector3((Math.random() - 0.5), (Math.random() - 0.5), (Math.random() - 0.5)).normalize().multiplyScalar(Math.random() * 7 + 3);
                particle.userData.lifespan = 1.2;
                particles.push(particle);
                scene.add(particle);
            }
        }
        
        function createHumanoidAvatar() {
            const avatar = new THREE.Group();
            const shaderMaterial = new THREE.ShaderMaterial({
                uniforms: { time: { value: 0 }, color: { value: new THREE.Color(0x00ffff) }, glowColor: { value: new THREE.Color(0x00ffff) } },
                vertexShader: ` varying vec3 vNormal; varying vec3 vPosition; void main() { vNormal = normalize(normalMatrix * normal); vPosition = (modelViewMatrix * vec4(position, 1.0)).xyz; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); } `,
                fragmentShader: ` uniform float time; uniform vec3 color; uniform vec3 glowColor; varying vec3 vNormal; varying vec3 vPosition; void main() { vec3 viewDir = normalize(-vPosition); float fresnel = 1.0 - dot(viewDir, vNormal); fresnel = pow(fresnel, 2.0); float scanline = sin(vPosition.y * 20.0 - time * 10.0) * 0.1 + 0.9; vec3 finalColor = mix(color, glowColor, fresnel); gl_FragColor = vec4(finalColor * scanline, fresnel * 0.8 + 0.2); } `,
                transparent: true, blending: THREE.AdditiveBlending
            });
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.5, 16, 16), shaderMaterial); head.position.y = 1.5;
            const torso = new THREE.Mesh(new THREE.BoxGeometry(1, 1.5, 0.5), shaderMaterial);
            const armL = new THREE.Mesh(new THREE.BoxGeometry(0.25, 1.2, 0.25), shaderMaterial); armL.position.set(-0.7, 0.2, 0);
            const armR = armL.clone(); armR.position.x = 0.7;
            const legL = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.5, 0.3), shaderMaterial); legL.position.set(-0.3, -1.5, 0);
            const legR = legL.clone(); legR.position.x = 0.3;
            avatar.add(head, torso, armL, armR, legL, legR);
            avatar.userData.limbs = { head, torso, armL, armR, legL, legR };
            avatar.userData.material = shaderMaterial;
            return avatar;
        }

        function updatePlayerAvatar() {
            if (playerAvatar) player.remove(playerAvatar);
            playerAvatar = createHumanoidAvatar();
            const scale = 1 + (evolutionLevel - 1) * 0.25;
            playerAvatar.scale.set(scale, scale, scale);
            player.add(playerAvatar);
        }
        
        function updateAvatarPose(delta) {
            if (!playerAvatar) return;
            const { armL, armR, legL, legR } = playerAvatar.userData.limbs;
            const lerpFactor = delta * 5;
            if (isLocking) {
                armL.rotation.x = THREE.MathUtils.lerp(armL.rotation.x, -Math.PI / 2, lerpFactor); armR.rotation.x = THREE.MathUtils.lerp(armR.rotation.x, -Math.PI / 2, lerpFactor);
                legL.rotation.x = THREE.MathUtils.lerp(legL.rotation.x, 0, lerpFactor); legR.rotation.x = THREE.MathUtils.lerp(legR.rotation.x, 0, lerpFactor);
                legL.position.z = THREE.MathUtils.lerp(legL.position.z, 0, lerpFactor); legR.position.z = THREE.MathUtils.lerp(legR.position.z, 0, lerpFactor);
            } else {
                armL.rotation.x = THREE.MathUtils.lerp(armL.rotation.x, -Math.PI / 4, lerpFactor); armR.rotation.x = THREE.MathUtils.lerp(armR.rotation.x, -Math.PI / 4, lerpFactor);
                legL.rotation.x = THREE.MathUtils.lerp(legL.rotation.x, Math.PI / 2, lerpFactor); legR.rotation.x = THREE.MathUtils.lerp(legR.rotation.x, -Math.PI / 2, lerpFactor);
                legL.position.z = THREE.MathUtils.lerp(legL.position.z, 0.5, lerpFactor); legR.position.z = THREE.MathUtils.lerp(legR.position.z, -0.5, lerpFactor);
            }
        }

        function triggerOverdrive() {
            if (overdrive < 100) return;
            overdrive = 0;
            updateOverdrive(0);
            fireWhoosh.triggerAttackRelease("0.5n");
            const shockwaveGeo = new THREE.SphereGeometry(1, 32, 32);
            const shockwaveMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 });
            overdriveShockwave = new THREE.Mesh(shockwaveGeo, shockwaveMat);
            overdriveShockwave.position.copy(player.position);
            scene.add(overdriveShockwave);
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                createExplosion(enemy.getWorldPosition(new THREE.Vector3()), enemy.material.color);
                updateScore(50);
                enemy.parent.remove(enemy);
                enemies.splice(i, 1);
            }
        }

        // --- Game Loop and Logic ---
        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            if (!gameStarted || isPaused) return;
            
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            pathProgress += delta * 0.01;
            if (pathProgress >= 1) { pathProgress = 0; nextEventIndex = 0; showMessage("SYSTEM LOOP COMPLETE"); }
            
            checkLevelEvents();

            const currentPos = path.getPointAt(pathProgress);
            const nextPos = path.getPointAt((pathProgress + 0.001) % 1);
            camera.position.copy(currentPos);
            camera.lookAt(nextPos);
            
            player.position.copy(camera.position).add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(15));
            player.lookAt(camera.position.clone().add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(20)));
            
            updateAvatarPose(delta);
            if(playerAvatar) playerAvatar.userData.material.uniforms.time.value = time;

            if (overdriveShockwave) {
                overdriveShockwave.scale.x += delta * 300; overdriveShockwave.scale.y += delta * 300; overdriveShockwave.scale.z += delta * 300;
                overdriveShockwave.material.opacity -= delta * 0.8;
                if (overdriveShockwave.material.opacity <= 0) { scene.remove(overdriveShockwave); overdriveShockwave = null; }
            }
            
            updateEnemies(delta, time);
            updateProjectiles(delta);
            updateParticles(delta);
            
            if (isLocking) handleLocking();

            renderer.render(scene, camera);
        }

        function updateEnemies(delta, time) {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const group = enemy.userData.formationGroup;
                enemy.rotation.y += delta * 0.5;
                if (enemy.userData.movement === 'wave') { enemy.position.y = enemy.userData.initialPos.y + Math.sin(time * 3 + enemy.userData.initialPos.x) * 5; }
                if (enemy.userData.movement === 'rotate') { group.rotation.z += delta * 0.5; }
                const worldPos = enemy.getWorldPosition(new THREE.Vector3());
                if (worldPos.distanceTo(player.position) < 3) { playerTakeDamage(); group.remove(enemy); enemies.splice(i, 1); continue; }
                const distanceToPlayer = worldPos.distanceTo(camera.position);
                const directionToPlayer = worldPos.clone().sub(camera.position).normalize();
                const cameraDirection = camera.getWorldDirection(new THREE.Vector3());
                const dot = directionToPlayer.dot(cameraDirection);
                if (dot < -0.5 && distanceToPlayer > 100) { group.remove(enemy); enemies.splice(i, 1); }
            }
        }
        
        function updateProjectiles(delta) {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.userData.t += delta / p.userData.speed;
                if (p.userData.t >= 1) {
                    scene.remove(p);
                    projectiles.splice(i, 1);
                } else {
                    // Animate along curve
                    const pos = p.userData.curve.getPoint(p.userData.t);
                    p.position.copy(pos);
                    // Animate opacity for Rez effect
                    p.material.opacity = 0.5 + 0.5 * Math.sin(p.userData.t * Math.PI);
                }
            }
        }
        
        function updateParticles(delta) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.userData.lifespan -= delta;
                if (p.userData.lifespan <= 0) { scene.remove(p); particles.splice(i, 1); } 
                else { p.position.add(p.userData.velocity.clone().multiplyScalar(delta)); p.material.opacity = p.userData.lifespan; }
            }
        }

        function handleLocking() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(enemies);
            if (intersects.length > 0) {
                const target = intersects[0].object;
                if (!target.userData.isLocked && lockedTargets.length < MAX_LOCKS && canLockSound) {
                    canLockSound = false;
                    target.userData.isLocked = true;
                    target.userData.outline.material.opacity = 1;
                    lockedTargets.push(target);
                    const note = ['C4', 'D4', 'E4', 'G4', 'A4', 'C5', 'D5', 'E5'][lockedTargets.length - 1];
                    Tone.Transport.scheduleOnce(time => {
                        lockOnSynth.triggerAttackRelease(note, '16n', time);
                        canLockSound = true;
                    }, "@16n");
                }
            }
        }

        function fireProjectiles() {
            if (!gameStarted || isPaused || lockedTargets.length === 0) return;
            // Sort targets by their screen X position for a true sweep
            const sortedTargets = lockedTargets.slice().sort((a, b) => {
                const aPos = a.getWorldPosition(new THREE.Vector3());
                const bPos = b.getWorldPosition(new THREE.Vector3());
                const aScreen = aPos.project(camera);
                const bScreen = bPos.project(camera);
                return aScreen.x - bScreen.x;
            });
            sortedTargets.forEach((target, i) => {
                setTimeout(() => {
                    const startPos = player.position.clone();
                    const endPos = target.getWorldPosition(new THREE.Vector3());
                    createProjectile(startPos, endPos);
                    // Rhythmic synth shot
                    if (lockOnSynth) lockOnSynth.triggerAttackRelease('C5', '16n', undefined, 0.7 - i*0.05);
                    if (fireWhoosh) fireWhoosh.triggerAttackRelease('16n', undefined, 0.5 + i*0.05);
                    setTimeout(() => {
                        const index = enemies.indexOf(target);
                        if (index > -1) {
                            const worldPos = target.getWorldPosition(new THREE.Vector3());
                            target.parent.remove(target);
                            enemies.splice(index, 1);
                            // Add a small offset to avoid Tone.js scheduling error
                            Tone.Transport.scheduleOnce(time => {
                                kick.triggerAttackRelease('C2', '8n', time);
                                clap.triggerAttackRelease('8n', time + 0.001);
                            }, `@16n+${i*0.05+0.001}`);
                            createExplosion(worldPos, target.material.color);
                            updateScore(100 * (i + 1));
                        }
                    }, 150);
                }, i * 60); // Stagger sweep
            });
            updateOverdrive(lockedTargets.length);
            // Reset lock states
            enemies.forEach(e => { if (e.userData.isLocked) { e.userData.isLocked = false; e.userData.outline.material.opacity = 0; } });
            lockedTargets = [];
        }
        
        // --- UI and State Updates ---
        
        function updateScore(points) {
            if (!gameStarted) return;
            score += points;
            scoreEl.textContent = `Score: ${score}`;
            const oldLevel = evolutionLevel;
            evolutionLevel = Math.min(4, Math.floor(score / 2000) + 1);
            if (evolutionLevel > oldLevel) {
                updatePlayerAvatar();
                levelEl.textContent = `Evolution: ${evolutionLevel}`;
                showMessage(`EVOLUTION LEVEL ${evolutionLevel}`);
                if (evolutionLevel >= 2 && bassLoop.state !== 'started') bassLoop.start("@1m");
                if (evolutionLevel >= 3 && melodyLoop.state !== 'started') melodyLoop.start("@1m + 0.001");
                if (padSynth) padSynth.set({ detune: (evolutionLevel - 1) * 100 });
            }
        }
        
        function updateOverdrive(amount) {
            overdrive = Math.min(100, overdrive + amount * 2);
            overdriveEl.textContent = `Overdrive: ${Math.floor(overdrive)}%`;
            if (overdrive >= 100) { overdriveEl.style.color = '#00ff00'; overdriveEl.style.textShadow = '0 0 10px #00ff00'; } 
            else { overdriveEl.style.color = '#fff'; overdriveEl.style.textShadow = '0 0 5px #0ff'; }
        }
        
        function playerTakeDamage() {
            if (!gameStarted) return;
            if (fireWhoosh) fireWhoosh.triggerAttackRelease("8n");
            evolutionLevel--;
            if (evolutionLevel < 1) { gameOver(); return; }
            if (evolutionLevel < 3 && melodyLoop.state === 'started') melodyLoop.stop();
            if (evolutionLevel < 2 && bassLoop.state === 'started') bassLoop.stop();
            if (padSynth) padSynth.set({ detune: (evolutionLevel - 1) * 100 });
            updatePlayerAvatar();
            levelEl.textContent = `Evolution: ${evolutionLevel}`;
            showMessage(`SYSTEM DEGRADE - EVOLUTION ${evolutionLevel}`);
        }

        function gameOver() {
            gameStarted = false; isPaused = true;
            gameTitleEl.textContent = "GAME OVER";
            instructionsEl.innerHTML = `Final Score: ${score}<br>Refresh to try again.`;
            startScreen.style.display = 'flex'; startScreen.style.opacity = 1;
            startButton.style.display = 'none';
        }

        function showMessage(text) {
            messageBox.textContent = text;
            messageBox.classList.add('show');
            setTimeout(() => { messageBox.classList.remove('show'); }, 2000);
        }

        function toggleMute() {
            isMuted = !isMuted;
            Tone.Master.mute = isMuted;
            muteButton.textContent = isMuted ? 'Unmute' : 'Mute';
        }

        function pauseGame() {
            if (!gameStarted) return;
            isPaused = true; clock.stop();
            Tone.Transport.pause();
            helpMenu.style.display = 'flex';
        }

        function resumeGame() {
            isPaused = false; clock.start();
            Tone.Transport.start();
            helpMenu.style.display = 'none';
        }

        // --- Event Handlers ---

        function onKeyDown(event) { if (event.code === 'Space' && gameStarted && !isPaused) { triggerOverdrive(); } }
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            // Set reticle position to cursor
            reticleEl.style.left = `${event.clientX}px`;
            reticleEl.style.top = `${event.clientY}px`;
            reticleEl.style.transform = "translate(-50%, -50%)";
        }
        function onMouseDown(event) { if (event.button === 0 && gameStarted && !isPaused) { isLocking = true; reticleEl.classList.add('locking'); } }
        function onMouseUp(event) {
            if (event.button === 0 && gameStarted && !isPaused) {
                isLocking = false; reticleEl.classList.remove('locking');
                fireProjectiles();
                enemies.forEach(e => { if (e.userData.isLocked) { e.userData.isLocked = false; e.userData.outline.material.opacity = 0; } });
            }
        }

        startButton.addEventListener('click', async () => {
            if (Tone.context.state !== 'running') {
                await Tone.start();
                console.log('Audio context started');
            }
            
            initAudio();

            startScreen.style.opacity = 0;
            setTimeout(() => {
                startScreen.style.display = 'none';
            }, 500);
            
            gameStarted = true;
            animate();
        });

        init();
    </script>
</body>
</html>
